/*
Marshall Lindsay
ECE4220 Lab4

*/

#include <iostream>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <vector>
#include <sys/types.h>
#include <fcntl.h>
#include <semaphore.h>
#include <wiringPi.h>
#include "serial_ece4220.h"
#include "ece4220lab3.h"

using namespace std;

#define PRIORITY (51)
#define INIT_VALUE_EVENTS (1)
#define INIT_VALUE (0)
#define BUTTON (16)

sem_t gps_semaphore;
sem_t events_semaphore;


struct gpsData{
	struct timespec time;
	unsigned char value;

};

gpsData data;
vector <timespec> events;

int setupTheThings(void);
void* event(void*);
void* collection(void*);
void* interpolation(void*);

/*
The main thread will start by initializing the event thread, the collection
thread and the interpolation thread. It will open a serial connection and
read the gps data from the serial port. It will write this data to the global
gpsData struct and increment the gps_semaphore to indicate a new value has
been received.
*/

int main(void)
{
	int dummy;

	dummy = system("rm EventWatcher");
	dummy = system("mkfifo EventWatcher");


	struct timespec gps_time;
	sem_init(&gps_semaphore, 0, INIT_VALUE);
	sem_init(&events_semaphore, 0, INIT_VALUE_EVENTS);
	pthread_t collectionThread, interpolationThread, eventWatcherThread;

	//Setup the IO
	setupTheThings();

	// Open the serial port. The first argument denotes the serial port number,
	// while the second and third denote the baud rate (of 115200 in this case)
	int prt_id = serial_open(0,5,5);
	int num_bytes;
	unsigned char x;

	usleep(10);
	pthread_create(&collectionThread, NULL, collection, NULL);
	pthread_create(&interpolationThread, NULL, interpolation, NULL);

	//Elevate the thread priority
	struct sched_param param;
	param.sched_priority = PRIORITY;
	sched_setscheduler(0, SCHED_FIFO, &param);

	//Read GPS data from the serial port.
	//Get a time stamp.
	//Place the gps data and the time stamp in a structure.
	//Increment the gps semaphore to indicate new data is available.
	while(1)
	{

		//Read data from the serial port. Blocking function
		num_bytes = read(prt_id, &x, 1);

		//Get a time stamp.
		clock_gettime(CLOCK_REALTIME, &gps_time);

		//Place the gps data and the time stamp in a structure.
		data.value = x;
		data.time = gps_time;
		//cout<<"\n"<<(int)(data.value)<<endl;

		//Increment the gps semaphore to indicate new data is available.
		sem_post(&gps_semaphore);
	}



	return(0);
}

int setupTheThings(void){
	//Copy pasta
	wiringPiSetupGpio();
	pinMode(BUTTON, INPUT);
	pullUpDnControl(BUTTON, PUD_DOWN);
}

/*
The purpose of the event thread is to read the named pipe between this process
and the event processs. It will take the time from the named pipe and put it
into a shared buffer to be read by the collection thread.
*/

void* event(void*){

	//Variable to hold the time sent via the named pipe
	struct timespec event_time;

	//Open the named pipe
	int pipe_fromEvent;
	if((pipe_fromEvent = open("EventWatcher", O_RDONLY)) < 0){
		cout<<"\nEventWatcher pipe reading error"<<endl;
		exit(-1);
	}

	cout<<"\nEntering loop"<<endl;
	while(1){
		//Read from the named pipe.
		//Add the value to the global event time vector

		//Read from the named pipe.
		if(read(pipe_fromEvent, &event_time, sizeof(event_time)) < 0){
			cout<<"\nPipe read error"<<endl;
		}
		cout<<"\nValue from events named pipe was read"<<endl;

		//Add the value to the global event time vector
		//Going to include a semaphore because it is a shared resource.
		sem_wait(&events_semaphore);
		events.push_back(event_time);
		sem_post(&events_semaphore);

	}

}

/*
The purpose of the collection thread is to monitor the gps_semaphore which
indicates another cylce has passed. It will then copy the gps data from the
global gpsData struct and copy the data from the events vector. It will then
send this information to the inerpolation thread for processing. Once read,
the events vector will be cleared.
*/

void* collection(void*){
		//Create a vector of data to send to the interpolation thread.
		gpsData dummyData;
		vector<gpsData> collected;
		vector<timespec> e_vector; //Running out of variable names...

		//Wait for the gps_semaphore
		sem_wait(&gps_semaphore);
		if(collected.length() < 2){
			collected.push_back(data);
		}
		//Lock the events_semaphore
		sem_wait(&events_semaphore);

		//Copy the events data
		e_vector = events;

		//Clear the shared vector
		events.clear();

		//Release the events semaphore
		sem_post(&events_semaphore);

		//Format the data to be sent to the interpolation thread
		//Using pop_back() so the most recent event will be first
		//need to decide how I want to send the data to the interpolation thread.***********************************
}

void* interpolation(void*){

}
